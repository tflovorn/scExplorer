package tempAll

import (
	"math"
	"reflect"
)
import (
	"../bzone"
	"../serialize"
	vec "../vector"
)

// Container for variables relevant at all temperatures.
type Environment struct {
	// Program parameters:
	PointsPerSide int // length of one side of the lattice

	// Constant physical parameters:
	X     float64 // average density of holons
	T0    float64 // nn one-holon hopping energy
	Thp   float64 // direct nnn one-holon hopping energy
	Tz    float64 // inter-planar one-holon hopping energy
	Alpha int     // SC gap symmetry parameter (s-wave = +1, d-wave = -1)

	// Dynamically determined physical parameters:
	D1   float64 // nnn hopping parameter generated by two-holon hopping
	Mu_h float64 // holon chemical potential

	// May be constant or dynamically determined:
	Beta float64 // inverse temperature
	F0   float64 // superconducting order parameter (0 if T >= Tc)
	Mu_b float64 // holon pair (bosonic) chemical potential (0 if T <= Tc)

	// Cached values:
	epsilonMinCache  float64
	lastEpsilonMinD1 float64
}

// Create an Environment from the given serialized data.
func NewEnvironment(jsonData string) (*Environment, error) {
	// initialize env with input data
	env := new(Environment)
	err := serialize.CopyFromJSON(jsonData, env)
	if err != nil {
		return nil, err
	}
	// initialize cache
	env.setEpsilonMinCache()
	env.lastEpsilonMinD1 = env.D1

	return env, nil
}

// Scaled hopping energy
func (env *Environment) Th() float64 {
	return env.T0 * (1.0 - env.X)
}

// Single-holon energy. Minimum is 0.
// env.EpsilonMin must be set to the value returned by EpsilonMin before
// calling this function.
func (env *Environment) Epsilon_h(k vec.Vector) float64 {
	return env.epsilonBar(k) - env.getEpsilonMin()
}

// Single-holon energy without fixed minimum.
func (env *Environment) epsilonBar(k vec.Vector) float64 {
	sx, sy := math.Sin(k[0]), math.Sin(k[1])
	return 2.0*env.Th()*((sx+sy)*(sx+sy)-1) + 4.0*(env.D1*env.T0-env.Thp)*sx*sy
}

// Get minimum value of env.Epsilon. If env.D1 hasn't changed since the last
// call to this function, return a cached value.
func (env *Environment) getEpsilonMin() float64 {
	if env.D1 != env.lastEpsilonMinD1 {
		env.setEpsilonMinCache()
		env.lastEpsilonMinD1 = env.D1
	}
	return env.epsilonMinCache
}

// Find the minimum of EpsilonBar.
func (env *Environment) setEpsilonMinCache() {
	worker := func(k vec.Vector) float64 {
		return env.epsilonBar(k)
	}
	env.epsilonMinCache = bzone.Min(env.PointsPerSide, 2, worker)
}

// Single-holon energy minus chemical potential. Minimum is -env.Mu_h.
func (env *Environment) Xi_h(k []float64) float64 {
	return env.Epsilon_h(k) - env.Mu_h
}

// Superconducting gap function.
func (env *Environment) Delta_h(k vec.Vector) float64 {
	return 4.0 * (env.T0 + env.Tz) * env.F0 * (math.Sin(k[0]) + float64(env.Alpha)*math.Sin(k[1]))
}

// Bogolyubov quasiparticle energy.
func (env *Environment) BogoEnergy(k vec.Vector) float64 {
	xi := env.Xi_h(k)
	delta := env.Delta_h(k)
	return math.Sqrt(xi*xi + delta*delta)
}

// Fermi distribution function.
func (env *Environment) Fermi(energy float64) float64 {
	// Temperature is 0 or e^(Beta*energy) is too big to calculate
	if env.Beta == math.Inf(1) || env.Beta*energy >= math.Log(math.MaxFloat64) {
		if energy <= 0 {
			return 1.0
		}
		return 0.0
	}
	// nonzero temperature
	return 1.0 / (math.Exp(energy*env.Beta) + 1.0)
}

// Iterate through v and vars simultaneously. vars specifies the names of
// fields to change in env (they are set to the values given in v).
// If vars specifies a field not contained in env (or a field of non-float
// type), the corresponding value is silently ignored.
func (env *Environment) Set(v vec.Vector, vars []string) {
	ev := reflect.ValueOf(env).Elem()
	for i := 0; i < len(vars); i++ {
		field := ev.FieldByName(vars[i])
		if field == reflect.Zero(reflect.TypeOf(env)) {
			continue
		}
		if field.Type().Kind() != reflect.Float64 {
			continue
		}
		field.SetFloat(v[i])
	}
}
